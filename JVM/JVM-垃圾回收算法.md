# 一、分代收集理论

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.png?raw=true)

+ 根据对象存活周期的不同将内存分为几个模块。
+ 将java堆分为新生代和老年代，这样可以根据各个年代的特点选择各自适合的垃圾收集算法。

# 二、标记-复制算法

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png?raw=true)

## 2.1、原理：

主要是**将内存分为大小相同的两块**，每次使用其中一块进行存放，当这一块内存使用完后，就将存活的对象复制到另一块，

这样每次内存回收只需要对内存区间的一半进行回收。

## 2.2、优点：

内存整理方便，将存活的对象直接移到领一块内存区域，情况正在使用的内存区域，不会产生内存碎片。

适用于新生代，将内存区分为两部分，回收效率高。

## 2.3、缺点：

将内存空间一分为二，对内存消耗大，不适用老年带。

# 三、标记-清除算法

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png?raw=true)

## 3.1、原理：

该算法分为两个阶段：

+ 标记阶段：标记出需要回收的对象

+ 清除阶段：清除被标记的对象

## 3.2、产生的问题：

+ 效率问题：如果堆内存的空间过大，对象过多，则回收效率不高。

+ 空间问题：标记清除后，内存区域会产生大量不连续的空间碎片。


# 四.标记-整理算法

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png?raw=true)

该算法是根据老年代特点设计出的一种标记算法，标记过程仍与**标记-清除**算法一样，只是多了一步整理操作。

步骤：

1. 标记垃圾对象。
2. 让所有存活的对象向向内存的一端移动。
3. 清理掉边界意外的内存。