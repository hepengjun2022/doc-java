# 一、什么是索引

索引是帮助MySQL高效获取数据的排好序的数据结构。

# 二、Mysql的数据结构

## 1.Hash表

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-Hash%E8%A1%A8%E7%BB%93%E6%9E%84.png?raw=true)

### ①.介绍

<font color='red'>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。</font>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code),  哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

### ②.优缺点

**优点：**

精确查找速度快。 

**缺点：**

1. 不适用于范围查找。
2. hash码的计算可能存在hash冲突
3. 需要进行两次查找，第一次找到相应行，第二次读取数据。

## 2.B-Tree

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-B%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

### ①.特点

1. 每个节点都存有所需要的全部数据。

### ②.m阶B-Tree满足条件

1. 每个节点最多拥有m个子树
2. 根节点至少有2个子树
3. 分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）
4. 所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列

### ③.总结

插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势--自平衡。

B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。

## 3.B+Tree

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-B+%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

### ①.优点

1.范围查找快，因为叶子节点组成双向循环链表

2.使用索引时，不能跳过索引中的列（最左匹配原则）

# 三、索引分类

**从数据结构角度可分为：**

+ B+树索引
+ 哈希索引
+ FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）
+ R-Tree索引（用于对GIS数据类型创建SPATIAL索引）； 

**从物理存储角度可分为：**

+ 聚集索引（clustered index）
+ 非聚集索引（non-clustered index）； 

**从逻辑角度可分为：**

+ 主键索引
+ 普通索引或者单列索引
+ 多列索引
+ 唯一索引
+ 非唯一索引等等

## 1、聚集索引/聚簇索引 

InnoDB中使用了聚集索引，就是将表的主键用来构造一棵B+树，并且将整张表的行记录数据存放在该B+树的叶子节点中。也就是所谓的索引即数据，数据即索引。由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集索引。 

聚集索引的叶子节点就是数据页。换句话说，数据页上存放的是完整的每行记录。 

因此聚集索引的优点就是：

+ 通过过聚集索引能获取完整的整行数据。

+ 对于主键的排序查找和范围查找速度非常快。 

**如果我们没有定义主键呢？**

MySQL会使用唯一性索引，没有唯一性索引，MySQL也会创建一个隐含列RowID来做主键，然后用这个主键来建立聚集索引。

![img]()

## 2、辅助索引/二级索引 

### ①.介绍

上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的,那如果我们想以别的列作为搜索条件怎么办？我们一般会建立多个索引，这些索引被称为辅助索引/二级索引。

对于辅助索引(Secondary Index，也称二级索引、非聚集索引)，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了相应行数据的聚集索引键。

![img]()

比如辅助索引index(node)，那么叶子节点中包含的数据就包括了(主键、note)。

### ②.回表

辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为回表。

也就是根据辅助索引的值查询一条完整的用户记录需要使用到2棵B+树----一次辅助索引，一次聚集索引。

![img]()

**思考：为什么我们还需要一次回表操作呢?直接把完整的用户记录放到辅助索引d的叶子节点不就好了么？**

如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太 浪费存储空间了。而且每次对数据的变化要在所有包含数据的索引中全部都修改一次，性能也非常低下。

 很明显，回表的记录越少，性能提升就越高，需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。

**思考：那什么时候采用全表扫描的方式，什么时候使用采用二级索引 + 回表的方式去执行查询呢？**

这个就是查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引+回表的方式。具体怎么算的，我们后面会详细说到。 

### ③.MRR

从上文可以看出，每次从二级索引中读取到一条记录后，就会根据该记录的主键值执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。 

每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机IO带来的性能开销比较大。MySQL中提出了一个名为Disk-Sweep Multi-Range Read (MRR，多范围读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执行回表操作。 

相对于每读取一条二级索引记录就立即执行回表操作，这样会节省一些IO开销。使用这个 MRR优化措施的条件比较苛刻，所以我们直接认为每读取一条二级索引记录就立即执行回表操作。MRR的详细信息，可以查询官方文档。

## 3、联合索引/复合索引

前面我们对索引的描述，隐含了一个条件，那就是构建索引的字段只有一个，但实践工作中构建索引的完全可以是多个字段。所以，将表上的多个列组合起来进行索引我们称之为联合索引或者复合索引，比如index(a,b)就是将a,b两个列组合起来构成一个索引。

千万要注意一点，建立联合索引只会建立1棵B+树，多个列分别建立索引会分别以每个列则建立B+树，有几个列就有几个B+树，比如，index(note)、index(b)，就分别对 note,b 两个列各构建了一个索引。 

index(note,b)在索引构建上，包含了两个意思： 

1. 先把各个记录按照note列进行排序。 

2. 在记录的note列相同的情况下，采用b列进行排序。

![img]()

## 4、自适应哈希索引

InnoDB存储引擎除了我们前面所说的各种索引，还有一种自适应哈希索引，我们知道B+树的查找次数,取决于B+树的高度,在生产环境中,B+树的高度一般为3~4层,故需要3~4次的IO查询。 

所以在InnoDB存储引擎内部自己去监控索引表，如果监控到某个索引经常用，那么就认为是热数据，然后内部自己创建一个hash索引，称之为自适应哈希索引( Adaptive Hash Index,AHI)，创建以后，如果下次又查询到这个索引，那么直接通 过hash算法推导出记录的地址，直接一次就能查到数据，比重复去B+tree索引中查询三四次节点的效率高了不少。 

<font color='red'>InnoDB存储引擎使用的哈希函数采用除法散列方式，其冲突机制采用链表方式。</font>

注意：对于自适应哈希索引仅是数据库自身创建并使用的，我们并不能对其进行干预。通过命令show engine innodb status\G可以看到当前自适应哈希索引的使用状况，如:

![img]()

<font color='red'>哈希索引只能用来搜索等值的查询。</font>如：

```mysql
 SELECT * FROM table WHERE index co=xxx
```

<font color='red'>而对于其他查找类型，如范围查找，是不能使用哈希索引的，</font> 因此这里会显示non- hash searches/s的统计情况。通过 hash searches: non- hash searches可以大概了解使用哈希索引后的效率。 

由于AHI是由 InnoDB存储引擎控制的,因此这里的信息只供我们参考。不过我们可以通过观察 SHOW ENGINE INNODB STATUS的结果及参数 innodb_adaptive_hash_index来考虑是禁用或启动此特性,默认AHI为开启状态。 

**什么时候需要禁用呢？**

如果发现监视索引查找和维护哈希索引结构的额外开销远远超过了自适应哈希索引带来的性能提升就需要关闭这个功能。

同时在MySQL 5.7中，自适应哈希索引搜索系统被分区。每个索引都绑定到一个特定的分区，每个分区都由一个单独的 latch 锁保护。分区由innodb_adaptive_hash_index_parts 配置选项控制 。

在早期版本中，自适应哈希索引搜索系统受到单个 latch 锁的保护，这可能成为繁重工作负载下的争用点。 

innodb_adaptive_hash_index_parts 默认情况下，该 选项设置为8。最大设置为512。当然禁用或启动此特性和调整分区个数这个应该是DBA的工作，我们了解即可。

## 5、全文检索之倒排索引

**什么是全文检索（Full-Text Search）？**

+ 它是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。

+ 它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。

+ 我们比较熟知的Elasticsearch、Solr等就是全文检索引擎，底层都是基于Apache Lucene的。 

举个例子，现在我们要保存唐宋诗词，数据库中我们们会怎么设计？诗词表我们可能的设计如下：

| 朝代 | 作者   | 诗词年代 | 标题   | 诗词全文                                                     |
| ---- | ------ | -------- | ------ | ------------------------------------------------------------ |
| 唐   | 李白   |          | 静夜思 | 床前明月光，疑是地上霜。 举头望明月， 低头思故乡。           |
| 宋   | 李清照 |          | 如梦令 | 常记溪亭日暮，沉醉不知归路，兴尽晚回舟，误入藕花深处。争渡，争渡，，惊起一滩鸥鹭。 |
| 。。 | 。。   | 。。     | 。。   | 。。。                                                       |

要根据朝代或者作者寻找诗，都很简单，比如“select 诗词全文 from 诗词表where作者=‘李白’”，如果数据很多，查询速度很慢，怎么办？我们可以在对应的查询字段上建立索引加速查询。

但是如果我们现在有个需求：要求找到包含“望”字的诗词怎么办？

用  “select 诗词全文 from 诗词表 where诗词全文 like‘%望%’”，这个意味着要扫描库中的诗词全文字段，逐条比对，找出所有包含关键词“望”字的记录，。基本上，数据库中一般的SQL优化手段都是用不上的。数量少，大概性能还能接受，如果数据量稍微大点，就完全无法接受了，更何况在互联网这种海量数据的情况下呢？怎么解决这个问题呢，用倒排索引。

比如现在有： 

蜀道难（唐）李白 蜀道之难难于上青天，侧身西望长咨嗟。 

静夜思（唐）李白 举头望明月，低头思故乡。 

春台望（唐）李隆基 暇景属三春，高台聊四望。

鹤冲天(宋)  柳永  黄金榜上，偶失龙头望。明代暂遗贤，如何向？未遂风云便，争不恣狂荡。何须论得丧？才子词人，自是白衣卿相。烟花巷陌，依约丹青屏障。幸有意中人，堪寻访。且恁偎红翠，风流事，平生畅。青春都一饷。忍把浮名，换了浅斟低唱！ 

都有望字，于是我们可以这么保存：

| 序号 | 关键字 | 蜀道难 | 静夜思 | 春台望 | 鹤天冲 |
| ---- | ------ | ------ | ------ | ------ | ------ |
| 1    | 绝     | 有     | 有     | 有     | 有     |
|      |        |        |        |        |        |

如果查哪个诗词中包含上，怎么办，上述的表格可以继续填入新的记录：

| 序号 | 关键字 | 蜀道难 | 静夜思 | 春台望 | 鹤天冲 |
| ---- | ------ | ------ | ------ | ------ | ------ |
| 1    | 忘     | 有     | 有     | 有     | 有     |
| 2    | 上     | 有     |        |        | 有     |

其实，上述诗词的中每个字都可以作为关键字，然后建立关键字和文档之间的对应关系，也就是标识关键字被哪些文档包含。 

所以，倒排索引就是，将文档中包含的关键字全部提取处理，然后再将关键字和文档之间的对应关系保存起来，最后再对关键字本身做索引排序。用户在检索某一个关键字是，先对关键字的索引进行查找，再通过关键字与文档的对应关系找到所在文档。 

在存储在关系型数据库中的数据，需要我们事先分析将数据拆分为不同的字段，而在es这类的存储中，需要应用程序根据规则自动提取关键字，并形成对应关系。 

这些预先提取的关键字，在全文检索领域一般被称为term（词项），文档的词项提取在es中被称为文档分析，这是全文检索很核心的过程，必须要区分哪些是词项，哪些不是，比如很多场景下，apple和apples是同一个东西，望和看其实是同一个动作。

## 6、Mysql中全文索引

### ①.介绍

MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引。从InnoDB 1.2.x版本开始，InnoDB存储引擎开始支持全文检索，对应的MySQL版本是5.6.x系列。 

注意，不管什么引擎，只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。

不过MySQL从设计之初就是关系型数据库，存储引擎虽然支持全文检索，整体架构上对全文检索支持并不好而且限制很多，比如每张表只能有一个全文检索的索引，不支持没有单词界定符( delimiter）的语言，如中文、日语、韩语等。

所以如果有大批量或者专门的全文检索需求，还是应该选择专门的全文检索引擎，毕竟Elastic靠着全文检索起家，然后产品化、公司化后依赖全文检索不断扩充产品线和应用场景，并推出商业版本的解决方案然后融资上市，现在的市值已达100亿美元（2021/12/06 -纽约证券交易所中的市值101.5亿美元）。 

具体如何使用InnoDB存储引擎的全文检索，只提供简单的使用说明，更多的详情请自行查阅相关官方文档或者书籍，我们不做任何技术支持。官方文档路径： https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html 

### ②.创建

创建表时创建全文索引 :

```mysql
create table fulltext_test ( 
    id int(11) NOT NULL AUTO_INCREMENT, 
    content text NOT NULL, 
    tag varchar(255), 
    PRIMARY KEY (id), 
    FULLTEXT KEY content_tag_fulltext(content,tag) 
) DEFAULT CHARSET=utf8;
```

在已存在的表上创建全文索引 :

```mysql
create fulltext index content_tag_fulltext on fulltext_test(content,tag);
```

通过 SQL 语句 ALTER TABLE 创建全文索引 :

```mysql
alter table fulltext_test add fulltext index content_tag_fulltext(content,tag);
```

### ③.使用全文索引

和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match和 against 关键字。

比如 ：

```mysql
select * from fulltext_test where match(content,tag) against('xxx xxx');
```

## 7、覆盖索引/索引覆盖

既然多个列可以组合起来构建为联合索引，那么辅助索引自然也可以由多个列组成。

覆盖索引也是我们经常见到的名词，InnoDB存储引擎支持覆盖索引(covering index，或称索引覆盖)，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

所以记住，覆盖索引可以视为索引优化的一种方式，而并不是索引类型的一种。 除了覆盖索引这个概念外，在索引优化的范围内，还有前缀索引、三星索引等一系列概念。 

![img]()

## 8、总结

**①.MySQL有哪些索引类型 ？**

+ 从数据结构角度可分为B+树索引、哈希索引、以及FULLTEXT索引（现在MyISAM和InnoDB 引擎都支持了）和R-Tree索引（用于对GIS数据类型创建SPATIAL索引）； 

+ 从物理存储角度可分为聚集索引（clustered index）、非聚集索引（non-clustered index）； 

+ 从逻辑角度可分为主键索引、普通索引，或者单列索引、多列索引、唯一索引、非唯一索引等等。 

**②.什么是密集索引和稀疏索引？** 

+ 密集索引的定义：叶子节点保存的不只是键值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引。 

+ 稀疏索引：叶子节点仅保存了键位信息以及该行数据的地址，有的稀疏索引只保存了键位信息机器主键。 

+ mysam存储引擎，不管是主键索引，唯一键索引还是普通索引都是稀疏索引，innodb存储引擎：有且只有一个密集索引。 

+ 所以，密集索引就是innodb存储引擎里的聚簇索引，稀疏索引就是innodb存储引擎里的普通二级索引。

**③.深入思考索引在查询中的使用** 

索引在查询中的作用到底是什么？在我们的查询中发挥着什么样的作用呢？ 

请记住： 

1. 一个索引就是一个B+树，索引让我们的查询可以快速定位和扫描到我们需要的数据记录上，加快查询的速度。 

2. 一个select查询语句在执行过程中一般最多能使用一个二级索引来加快查询，即使在where条件中用了多个二级索引。

# 四、使用索引的代价

世界上从来没有只有好处没有坏处的东西，如果你有，请你一定要告诉我，让我也感受一下。虽然索引是个好东西，在学习如何更好的使用索引之前先要了解一下使用它的代价，它在空间和时间上都会拖后腿。 

## 1、空间上的代价 

这个是显而易见的，每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点 都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成会占据很多的存储空间。 

## 2、时间上的代价 

每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是非叶子内节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。 

而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，这必然会对性能造成影响。

既然索引这么有用，我们是不是创建越多越好？既然索引有代价，我们还是别创建了吧？当然不是！按照经验，一般来说，一张表6-7个索引以下都能够取得比较好的性能权衡。

那么创建索引的时候有什么好的策略让我们充分利用索引呢？

# 五、高性能索引创建策略

正确地创建和使用索引是实现高性能查询的基础。前面我们已经了解了索引相关的数据结构，各种类型的索引及其对应的优缺点。现在我们一起来看看如何真正地发挥这些索引的优势。

## 1、索引列的类型尽量小 

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TTNYINT、NEDUMNT、INT、BIGTNT这么几种，它们占用的存储空间依次递增，我们这里所说的类型大小指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用NEDIUMINT就不要使用INT，这是因为: 

+ 数据类型越小，在查询时进行的比较操作越快（CPU层次) 

+ ·数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有 的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。 

## 2、利用索引选择性和前缀索引 

### ①.索引的选择性/离散性

+ 创建索引应该选择选择性/离散性高的列。索引的选择性/离散性是指，不重复的索引值（也称为基数，cardinality)和数据表的记录总数（N)的比值，范围从1/N到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。

+ 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 

+ 很差的索引选择性就是列中的数据重复度很高，比如性别字段，不考虑政治正确的情况下，只有两者可能，男或女。那么我们在查询时，即使使用这个索引，从概率的角度来说，依然可能查出一半的数据出来。 

比如下面这个表：

![img]()

哪列做为索引字段最好？当然是姓名字段，因为里面的数据没有任何重复，性别字段是最不适合做索引的，因为数据的重复度非常高。 

**怎么算索引的选择性/离散性？**

比如order_exp这个表： 

```mysql
select COUNT(DISTINCT order_no)/count(*) cnt from order_exp;
```

![img]()

```mysql
select COUNT(DISTINCT order_status)/count(*) cnt from order_exp;
```

![img]()

很明显，order_no列上的索引就比order_status列上的索引的选择性就要好，原因很简单，因为order_status列中的值只有-1,0,1三种。

### ②.前缀索引

有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的模拟哈希索引。

模拟哈希索引： 

order_exp表中order_note字段很长，想把它作为一个索引，我们可以增加一个order_not_hash字段来存储order_note的哈希值，然后在order_not_hash上建立索引，相对于之前的索引速度会有明显提升，一个是对完整的 order_note做索引，而后者则是用整数哈希值做索引，显然数字的比较比字符串的匹配要高效得多。

 但是缺陷也很明显： 

1. 需要额外维护order_not_hash字段； 

2. 哈希算法的选择决定了哈希冲突的概率，不良的哈希算法会导致重复值很多； 

3. 不支持范围查找。 

**还可以做些什么改进呢？**

还可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。一般情况下我们需要保证某个列前缀的选择性也是足够高的，以满足查询性能。（尤其对于BLOB、TEXT或者很长的VARCHAR类型的列，应该使用前缀索引，因为MySQL不允许索引这些列的完整长度）。 

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间)。 

前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。 

按照《阿里最新Java编程规范泰山版》中《(二) 索引规约》中的说法： 

![img]()

![img]()

中建议，这个前缀的长度为20比较合适，但是其实后面的“count(distinct left(列名, 

索引长度))/count(*)的区分度来确定”会更合适点。在工程实践中具体如何做呢？ 

可以这样： 

```mysql
SELECT COUNT(DISTINCT LEFT(order_note,3))/COUNT(*) AS sel3, 
COUNT(DISTINCT LEFT(order_note,4))/COUNT(*)AS sel4, 
COUNT(DISTINCT LEFT(order_note,5))/COUNT(*) AS sel5, 
COUNT(DISTINCT LEFT(order_note, 6))/COUNT(*) As sel6, 
COUNT(DISTINCT LEFT(order_note, 7))/COUNT(*) As sel7, 
COUNT(DISTINCT LEFT(order_note, 8))/COUNT(*) As sel8, 
COUNT(DISTINCT LEFT(order_note, 9))/COUNT(*) As sel9, 
COUNT(DISTINCT LEFT(order_note, 10))/COUNT(*) As sel10, 
COUNT(DISTINCT LEFT(order_note, 11))/COUNT(*) As sel11, 
COUNT(DISTINCT LEFT(order_note, 12))/COUNT(*) As sel12,
COUNT(DISTINCT LEFT(order_note, 13))/COUNT(*) As sel13, 
COUNT(DISTINCT LEFT(order_note, 14))/COUNT(*) As sel14, 
COUNT(DISTINCT LEFT(order_note, 15))/COUNT(*) As sel15, 
COUNT(DISTINCT order_note)/COUNT(*) As total 
FROM order_exp;
```

![img]()

可以看见，从第10个开始选择性的增加值很高，随着前缀字符的越来越多，选择度也在不断上升，但是增长到第15时，已经和第14没太大差别了，选择性提升的幅度已经很小了，都非常接近整个列的选择性了。 

那么针对这个字段做前缀索引的话，从第13到第15都是不错的选择，甚至第12也不是不能考虑。 

在上面的示例中，已经找到了合适的前缀长度，如何创建前缀索引: 

```mysql
ALTER TABLE order_exp ADD KEY (order_note(14)); 
```

建立前缀索引后查询语句并不需要更改： 

```mysql
select * from order_exp where order_note = 'xxxx' ; 
```

+ 前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。 

+ 有时候后缀索引 (suffix index)也有用途（例如，找到某个域名的所有电子邮件地址)。

+ MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。

+ 可以通过触发器或者应用程序自行处理来维护索引。 

## 3、只为用于搜索、排序或分组的列创建索引 

也就是说，只为出现在WHERE 子句中的列、连接子句中的连接列创建索引，而出现在查询列表中的列一般就没必要建立索引了，除非是需要使用覆盖索引。又或者为出现在 ORDER BY或GROUP BY子句中的列创建索引，这句话什么意思呢？

比如： 

```mysql
SELECT * FROM order_exp ORDER BY insert_time, order_status,expire_time; 
```

查询的结果集需要先按照insert_time值排序，如果记录的insert_time值相同，则需要按照order_status来排序，如果order_status的值相同，则需要按照expire_time排序。 

回顾一下联合索引的存储结构，u_idx_day_status索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。 

当然ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY order_status,expire_time, insert_time的顺序，那也是用不了B+树索引的，原因不用再说了吧。 

```mysql
SELECT insert_time, order_status,expire_time,count(*) FROM order_exp GROUP BY insert_time, order_status,expire_time;
```

这个查询语句相当于做了3次分组操作： 

先把记录按照insert_time值进行分组，所有insert_time值相同的记录划分为一组。 

将每个insert_time值相同的分组里的记录再按照order_status的值进行分组，将 order_status值相同的记录放到一个小分组里。 

再将上一步中产生的小分组按照expire_time的值分成更小的分组。 

然后针对最后的分组进行统计，如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的u_idx_day_status索引中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+树索引进行分组。和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致。 

## 4、合理设计多列索引 

很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。 

我们遇到的最容易引起困惑的问题就是索引列的顺序。正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。反复强调过，在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、 GROUP BY 和 DISTINCT 等子句的查询需求。 

所以多列索引的列顺序至关重要。对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在WHERE子句中只使用了索引部分前缀列的查询来说选择性也更高。 

然而，性能不只是依赖于索引列的选择性，也和查询条件的有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，比如排序和分组，让这种情况下索引的选择性最高。同时，在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。 

## 5、尽可能设计三星索引 

### ①.三星索引概念

对于一个查询而言，一个三星索引，可能是其最好的索引。

如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次窄索引片的扫描，因此其相应时间通常比使用一个普通索引的响应时间少几个数量级。 

三星索引概念是在《Rrelational Database Index Design and the optimizers》 一书（这本书也是《高性能MySQL》作者强烈推荐的一本书）中提出来的。原文如下： 

The index earns one star if it places relevant rows adjacent to each other, a second star if its rows are sorted in the order the query needs, and a final star if it contains all the columns needed for the query. 

+ 索引将相关的记录放到一起则获得一星； 

+ 如果索引中的数据顺序和查找中的排列顺序一致则获得二星； 

+ 如果索引中的列包含了查询中需要的全部列则获得三星。 

**一星：**

按照原文稍微有点难以理解，其实它的意思就是：如果一个查询相关的索引行是相邻的或者至少相距足够靠近的话，必须扫描的索引片宽度就会缩至最短，也就是说，让索引片尽量变窄，也就是我们所说的索引的扫描范围越小越好。

**二星（排序星）：** 

在满足一星的情况下，当查询需要排序，group by、 order by，如果查询所需的顺序与索引是一致的（索引本身是有序的），是不是就可以不用再另外排序了，一般来说排序可是影响性能的关键因素。 

**三星（宽索引星）：** 

在满足了二星的情况下，如果索引中所包含了这个查询所需的所有列（包括 where 子句 和 select 子句中所需的列，也就是覆盖索引），这样一来，查询就不再需要回表了， 减少了查询的步骤和IO请求次数，性能几乎可以提升一倍。

**这三颗星，哪颗最重要？**

第三颗星。因为将一个列排除在索引之外可能会导致很多磁盘随机读（回表操作）。第一和第二颗星重要性差不多，可以理解为第三颗星比重是50%， 第一颗星为27%，第二颗星为23%，所以在大部分的情况下，会先考虑第一颗星，但会根据业务情况调整这两颗星的优先度。 

### ②.达成三星索引

现在有表：

```mysql
create table customer( 
    cno int, 
    lname varchar(10), 
    fname varchar(10), 
    sex int, weight int, 
    city varchar(10)
);
```

建立索引：

```mysql
create index idx_cust on customer(city,lname,fname,cno);
```

对于下面的SQL而言，这是个三星索引 :

```mysql
select cno,fname from customer where lname =’xx’ and city =’yy’ order by fname;
```

来评估下： 

第一颗星：所有等值谓词的列，是组合索引的开头的列，可以把索引片缩得很窄，符合。

第二颗星：order by的fname字段在组合索引中且是索引自动排序好的，符合。 

第三颗星：select中的cno字段、fname字段在组合索引中存在，符合。 

### ③.达不成三星索引

达不成三星索引 

现在有表 

```mysql
CREATE TABLE `test` ( 
    `id` int(11) NOT NULL AUTO_INCREMENT, 
    `user_name` varchar(100) DEFAULT NULL, 
    `sex` int(11) DEFAULT NULL, 
    `age` int(11) DEFAULT NULL, 
    `c_date` datetime DEFAULT NULL, 
    PRIMARY KEY (`id`), 
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8; 
```

SQL语句如下： 

```mysql
select user_name,sex,age from test where user_name like 'test%' and sex =1 ORDER BY age
```

如果我们建立索引(user_name,sex,age)： 

+ 第三颗星，满足 

+ 第一颗星，满足 

+ 第二颗星，不满足，user_name 采用了范围匹配，sex 是过滤列，此时age 列无法保证有序的。 

**上述我们看到，此时索引(user_name,sex,age)并不能满足三星索引中的第二颗星（排序）。** 

于是我们改改，建立索引(sex, age，user_name)： 

+ 第一颗星，不满足，只可以匹配到sex，sex选择性很差，意味着是一个宽索引片， 

+ 第二颗星，满足，等值sex 的情况下，age是有序的， 

+ 第三颗星，满足，select查询的列都在索引列中，对于索引(sex,age，user_name)我们可以看到，此时无法满足第一颗星，窄索引片的需求。

总结：

以上2个索引，都是无法同时满足三星索引设计中的三个需求的，我们只能尽力满足2个。而在多数情况下，能够满足2颗星，已经能缩小很大的查询范围了，具体最终要保留那一颗星（排序星 or 窄索引片星），这个就需要看查询者自己的着重点了，无法给出标准答案。 

## 6、主键尽量是很少改变的列

我们知道，行是按照聚集索引物理排序的，如果主键频繁改变(update)，物理顺序会改变，MySQL要不断调整B+树，并且中间可能会产生页面的分裂和合并等等，会导致性能会急剧降低。

## 7、处理冗余和重复索引 

MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。 

有时会在不经意间创建了重复索引，例如下面的代码: 

```mysql
CREATE TABLE test ( 
    ID INT NOT NULL PRIMARY KEY, 
    A INT NOT NULL, 
    B INT NOT NULL, 
    UNIQUE(ID), 
    INDEX(ID) 
) ENGINE=InnoDB; 
```

这里创建了一个主键，又加上唯一限制，然后再加上索引以供查询使用。

事实上，MySQL的唯一限制和主键限制都是通过索引实现的，因此，上面的写法实际上在相同的列上创建了三个重复的索引。通常并没有理由这样做，除非是在同一列上创建不同类型的索引来满足不同的查询需求。 

冗余索引和重复索引有一些不同。如果创建了索引(A B)，再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(AB)也可以当作索引(A)来使用（这种冗余只是对B-Tree索引来说的)。但是如果再创建索引 (B,A)，则不是冗余索引，索引(B)也不是，因为B不是索引(A,B)的最左前缀列。

已有的索引(A)，扩展为(A，ID)，其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。

解决冗余索引和重复索引的方法很简单，删除这些索引就可以，但首先要做的是找出这样的索引。可以通过写一些复杂的访问INFORMATION_SCHEMA表的查询来找。 

## 8、删除未使用的索引 

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除。

# 十、常见面试题

**1.数据库索引为什么不用AVL（平衡二叉树）？**

数据库索引是存储在磁盘上，磁盘IO操作比较耗时，为了提高查询效率就需要减少磁盘IO的次数。而磁盘IO次数和树的高度有关，所以为了减少磁盘IO就需要降低树的高度，这是查找的结构就可以把二叉树变成B类的树。

自答：

1.数据量够大，树高度增加，导致磁盘I/O性能降低。

2.二叉平衡树每一次动态平衡也会消耗性能。

**2.数据库索引为什么用B+树而不用B-树？**

数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

自答：

1. 首先如果用B-树作为数据索引,data数据是放在每个节点上，要知道mysql是页存储的，每个页page默认大小是16KB，如果采用B-树，那一页存储没有B+树多，如果数据量够大，就会导致树的高度增加，而每增加一次高度，比对次数增加。

2. 范围查找很麻烦，需要遍历，B+树只需要查找叶子节点即可。

**3.数据库索引为什么不用红黑树？**

首先看一下红黑树的特点：

红黑树是一种自平衡的二叉查找树，除了符合二叉查找树的基本特征外，它还具有下列的附加特征。

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 每个叶子节点都是黑色的空节点（NIL节点）。

4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

正是因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。

当插入或删除节点的时候，红黑树的规则可能被打破。这时候就需要做出一些调整， 来继续维持我们的规则。

**4.总结**

1. 使用B+树而不是用其他结构的原因就是为了减少磁盘IO的次数，减少树的高度，而B+树就很好的做到了这一点。

2. 当插入或删除节点的时候，红黑树的规则可能被打破。这时候就需要做出一些调整， 来继续维持我们的规则。那么在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。