# 一、什么是索引

索引是帮助MySQL高效获取数据的排好序的数据结构。

# 二、Mysql的数据结构

## 1.Hash表

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-Hash%E8%A1%A8%E7%BB%93%E6%9E%84.png?raw=true)

### ①.介绍

<font color='red'>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。</font>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code),  哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

### ②.优缺点

**优点：**

精确查找速度快。 

**缺点：**

1. 不适用于范围查找。
2. hash码的计算可能存在hash冲突
3. 需要进行两次查找，第一次找到相应行，第二次读取数据。

## 2.B-Tree

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-B%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

### ①.特点

1. 每个节点都存有所需要的全部数据。

### ②.m阶B-Tree满足条件

1. 每个节点最多拥有m个子树
2. 根节点至少有2个子树
3. 分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）
4. 所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列

### ③.总结

插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势--自平衡。

B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。

## 3.B+Tree

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-B+%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

### ①.优点

1.范围查找快，因为叶子节点组成双向循环链表

2.使用索引时，不能跳过索引中的列（最左匹配原则）

# 三、索引分类

**从数据结构角度可分为：**

+ B+树索引
+ 哈希索引
+ FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）
+ R-Tree索引（用于对GIS数据类型创建SPATIAL索引）； 

**从物理存储角度可分为：**

+ 聚集索引（clustered index）
+ 非聚集索引（non-clustered index）； 

**从逻辑角度可分为：**

+ 主键索引
+ 普通索引或者单列索引
+ 多列索引
+ 唯一索引
+ 非唯一索引等等

# 四、使用索引的代价

世界上从来没有只有好处没有坏处的东西，如果你有，请你一定要告诉我，让我也感受一下。虽然索引是个好东西，在学习如何更好的使用索引之前先要了解一下使用它的代价，它在空间和时间上都会拖后腿。 

## 1、空间上的代价 

这个是显而易见的，每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点 都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成会占据很多的存储空间。 

## 2、时间上的代价 

每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是非叶子内节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。 

而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，这必然会对性能造成影响。

既然索引这么有用，我们是不是创建越多越好？既然索引有代价，我们还是别创建了吧？当然不是！按照经验，一般来说，一张表6-7个索引以下都能够取得比较好的性能权衡。

那么创建索引的时候有什么好的策略让我们充分利用索引呢？

# 五、高性能索引创建策略

正确地创建和使用索引是实现高性能查询的基础。前面我们已经了解了索引相关的数据结构，各种类型的索引及其对应的优缺点。现在我们一起来看看如何真正地发挥这些索引的优势。

## 1、索引列的类型尽量小 

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TTNYINT、NEDUMNT、INT、BIGTNT这么几种，它们占用的存储空间依次递增，我们这里所说的类型大小指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用NEDIUMINT就不要使用INT，这是因为: 

+ 数据类型越小，在查询时进行的比较操作越快（CPU层次) 

+ ·数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有 的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。 

## 2、利用索引选择性和前缀索引 

### ①.索引的选择性/离散性

+ 创建索引应该选择选择性/离散性高的列。索引的选择性/离散性是指，不重复的索引值（也称为基数，cardinality)和数据表的记录总数（N)的比值，范围从1/N到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。

+ 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 

+ 很差的索引选择性就是列中的数据重复度很高，比如性别字段，不考虑政治正确的情况下，只有两者可能，男或女。那么我们在查询时，即使使用这个索引，从概率的角度来说，依然可能查出一半的数据出来。 

比如下面这个表：

![img]()

哪列做为索引字段最好？当然是姓名字段，因为里面的数据没有任何重复，性别字段是最不适合做索引的，因为数据的重复度非常高。 

**怎么算索引的选择性/离散性？**

比如order_exp这个表： 

```mysql
select COUNT(DISTINCT order_no)/count(*) cnt from order_exp;
```

![img]()

```mysql
select COUNT(DISTINCT order_status)/count(*) cnt from order_exp;
```

![img]()

很明显，order_no列上的索引就比order_status列上的索引的选择性就要好，原因很简单，因为order_status列中的值只有-1,0,1三种。

### ②.前缀索引

## 3、只为用于搜索、排序或分组的列创建索引 

## 4、合理设计多列索引 

## 5、尽可能设计三星索引 

## 6、主键尽量是很少改变的列

## 7、处理冗余和重复索引 

## 8、删除未使用的索引 

# 十、常见面试题

**1.数据库索引为什么不用AVL（平衡二叉树）？**

数据库索引是存储在磁盘上，磁盘IO操作比较耗时，为了提高查询效率就需要减少磁盘IO的次数。而磁盘IO次数和树的高度有关，所以为了减少磁盘IO就需要降低树的高度，这是查找的结构就可以把二叉树变成B类的树。

自答：

1.数据量够大，树高度增加，导致磁盘I/O性能降低。

2.二叉平衡树每一次动态平衡也会消耗性能。

**2.数据库索引为什么用B+树而不用B-树？**

数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

自答：

1. 首先如果用B-树作为数据索引,data数据是放在每个节点上，要知道mysql是页存储的，每个页page默认大小是16KB，如果采用B-树，那一页存储没有B+树多，如果数据量够大，就会导致树的高度增加，而每增加一次高度，比对次数增加。

2. 范围查找很麻烦，需要遍历，B+树只需要查找叶子节点即可。

**3.数据库索引为什么不用红黑树？**

首先看一下红黑树的特点：

红黑树是一种自平衡的二叉查找树，除了符合二叉查找树的基本特征外，它还具有下列的附加特征。

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 每个叶子节点都是黑色的空节点（NIL节点）。

4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

正是因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。

当插入或删除节点的时候，红黑树的规则可能被打破。这时候就需要做出一些调整， 来继续维持我们的规则。

**4.总结**

1. 使用B+树而不是用其他结构的原因就是为了减少磁盘IO的次数，减少树的高度，而B+树就很好的做到了这一点。

2. 当插入或删除节点的时候，红黑树的规则可能被打破。这时候就需要做出一些调整， 来继续维持我们的规则。那么在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。