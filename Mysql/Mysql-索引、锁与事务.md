# 一、索引

## 1.1、什么是索引

索引是帮助MySQL高效获取数据的排好序的数据结构。

## 1.2、Mysql的数据结构

### 1.Hash表

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-Hash%E8%A1%A8%E7%BB%93%E6%9E%84.png?raw=true)

#### ①.介绍

<font color='red'>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。</font>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code),  哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

#### ②.优缺点

**优点：**

精确查找速度快。 

**缺点：**

1. 不适用于范围查找。
2. hash码的计算可能存在hash冲突
3. 需要进行两次查找，第一次找到相应行，第二次读取数据。

### 2.B-Tree

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-B%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

#### ①.特点

1. 每个节点都存有所需要的全部数据。

#### ②.m阶B-Tree满足条件

1. 每个节点最多拥有m个子树
2. 根节点至少有2个子树
3. 分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）
4. 所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列

#### ③.总结

插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势--自平衡。

B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。

### 3.B+Tree

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-B+%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

#### ①.优点

1.范围查找快，因为叶子节点组成双向循环链表

2.使用索引时，不能跳过索引中的列（最左匹配原则）

## 1.3、常见面试题

**1.数据库索引为什么不用AVL（平衡二叉树）？**

数据库索引是存储在磁盘上，磁盘IO操作比较耗时，为了提高查询效率就需要减少磁盘IO的次数。而磁盘IO次数和树的高度有关，所以为了减少磁盘IO就需要降低树的高度，这是查找的结构就可以把二叉树变成B类的树。

自答：

1.数据量够大，树高度增加，导致磁盘I/O性能降低。

2.二叉平衡树每一次动态平衡也会消耗性能。

**2.数据库索引为什么用B+树而不用B-树？**

数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

自答：

1. 首先如果用B-树作为数据索引,data数据是放在每个节点上，要知道mysql是页存储的，每个页page默认大小是16KB，如果采用B-树，那一页存储没有B+树多，如果数据量够大，就会导致树的高度增加，而每增加一次高度，比对次数增加。

2. 范围查找很麻烦，需要遍历，B+树只需要查找叶子节点即可。

**3.数据库索引为什么不用红黑树？**

首先看一下红黑树的特点：

红黑树是一种自平衡的二叉查找树，除了符合二叉查找树的基本特征外，它还具有下列的附加特征。

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 每个叶子节点都是黑色的空节点（NIL节点）。

4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?raw=true)

正是因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。

当插入或删除节点的时候，红黑树的规则可能被打破。这时候就需要做出一些调整， 来继续维持我们的规则。

**4.总结**

1. 使用B+树而不是用其他结构的原因就是为了减少磁盘IO的次数，减少树的高度，而B+树就很好的做到了这一点。

2. 当插入或删除节点的时候，红黑树的规则可能被打破。这时候就需要做出一些调整， 来继续维持我们的规则。那么在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。

# 二、Mysql存储引擎

## 2.1、InnoDB存储引擎

#### 1.特点

1. innoDB支持事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。

2. innoDB支持外键。当删除、更新父表中的某条信息时，子表也必须有相应的改变。

3. InnoDB存储文件为两个，分别是frm,ibd文件。
   + frm文件：存储表的定义数据
   + IDB文件：存放表具体记录的索引和数据

注：由下面图可知，InnoDB他采用B-Tree索引存储时，它的叶子节点存放的是数据，所以InnoDB的B-Tree索引也就是聚簇索引。

#### 2.InnoDB索引实现

聚集索引

- 表数据文件本身就是按B+Tree组织的一个索引结构文件
- 聚集索引-叶节点包含了完整的数据记录

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png?raw=true)

## 2.2、MyISAM存储引擎

#### 1.特点

1. MyISAM不支持事务。

2. MyISAM的优势在于占用空间小，处理速度快。

3. MyISAM存储的存储三个文件，分别是frm、MYD、MYI。
   + frm文件：存储表的定义数据
   + MYD文件：存放表具体记录的数据
   + MYI文件：存储索引

注：由下面图可知，MyISAM他采用B-Tree索引存储时，它的叶子节点存放的是数据的物理地址，而非数据，所以MyISAM的B-Tree索引也就是非聚簇索引。

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png?raw=true)

## 2.3、Memory存储引擎

1. memory采用的逻辑存储是系统的内存，极大提高了存储数据表的能力。
2. 默认使用Hash索引，精确查找比B树快。
3. memory表的生命周期很短，，一般是一次性的，如果出现Mysql的守护线程崩溃，Memory的数据则会丢失。

## 2.4、Merge存储引擎

是由一组MyISAM的表组合，且表的结构必须完全相同，所以就相当于一个集合器。

# 三、Mysql事务

## 3.1、事务ACID属性

事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。 

### 1.原子性(Atomicity) 

事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。 

### 2.一致性(Consistent) 

在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规 

则都必须应用于事务的修改,以保持数据的完整性。 

### 3.隔离性(Isolation) 

数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 

### 4.持久性(Durable) 

事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。 

## 3.2、并发下事务的问题

### 1.更新丢失或脏写 

更新丢失：Lost Update

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存 在，就会发生丢失更新问题–**最后的更新覆盖了由其他事务所做的更新**。 

### 2.脏读

英文名：Dirty Reads

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。

总结：**事务A读取到了事务B已经修改但尚未提交的数据**，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。

### 3.不可重读

英文名：Non-Repeatable Reads

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 

总结：**事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性** 

### 4.幻读

英文名：Phantom Reads

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 

总结：**事务A读取到了事务B提交的新增数据，不符合隔离性** 

## 3.3、事务的隔离级别

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png?raw=true)

+ 数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。

+ 因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。

+ 不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读"和“幻读”并不敏感，可能更关心数据并发访问的能力。  

**常看当前数据库的事务隔离级别: show variables like 'tx_isolation';** 

**设置事务隔离级别：set tx_isolation='REPEATABLE-READ';** 

**Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别** 

# 四、Mysql锁

## 4.1、介绍

锁是计算机协调多个进程或线程并发访问某一资源的机制。 

在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。 

## 4.2、锁分类

+ 从性能上分为乐观锁和悲观锁 (用版本对比来实现)

+ 从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁) 
  + 读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响 
  + 写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁 

+ 从对数据操作的粒度分，分为表锁和行锁

## 4.3、表锁

每次操作锁住整张表。

### 1.特性

+ 开销小，加锁快。

+ 不会出现死锁。

+ 锁定粒度大，发生锁冲突的概率最高，并发度最低。 

+ 一般用在整表数据迁移的场景。 

### 2.基本操作

+ 手动增加表锁：lock table 表名称 read(write),表名称2 read(write)。
+ 查看表上加过的锁：show open tables。
+ 删除表锁：unlock tables。

### 3.案例分析

**加读锁：**

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E5%8A%A0%E8%AF%BB%E9%94%81.png?raw=true)

当前session和其他session都可以读该表。

当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待。

**加写锁：**

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E5%8A%A0%E5%86%99%E9%94%81.png?raw=true)

当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞 。

**总结：**

1. 对MyISAM表的读操作(加读锁) ，不会阻寒其他进程对同一表的读请求，但会阻赛对同一表的写请求。只有当读锁释放后才会执行其它进程的写操作。 
2. 对MylSAM表的写操作(加写锁) ，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后才会执行其它进程的读写操作。

## 4.4、行锁

每次操作锁住一行数据。

### 1.特性

+ 开销大，加锁慢。

+ 会出现死锁。
+ 锁定粒度最小，发生锁冲突的概率最低，并发度最高。

**InnoDB与MYISAM的最大不同有两点：** 

+ **InnoDB支持事务（TRANSACTION）** 

+ **InnoDB支持行级锁**

### 2.行锁分析

一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞。

通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况 

```mysql
show status like 'innodb_row_lock%'; 
```

对各个状态量的说明如下： 

+ Innodb_row_lock_current_waits: 当前正在等待锁定的数量 
+ Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 
+ Innodb_row_lock_time_avg: 每次等待所花平均时间 
+ Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间
+ Innodb_row_lock_waits：系统启动后到现在总共等待的次数

对于这5个状态变量，比较重要的主要是： 

+ Innodb_row_lock_time_avg （等待平均时长） 

+ Innodb_row_lock_waits （等待总次数） 

+ Innodb_row_lock_time（等待总时长） 

尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。 

### 3.总结

+ MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。 

+ InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。

简而言之，**读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞**。

## 4.5、间隙锁

Gap Lock

间隙锁，锁的就是两个值之间的空隙。

Mysql默认级别是repeatable-read，有办法解决幻读问题吗？

<font color='red'>间隙锁在某些情况下可以解决幻读问题。 </font>

假设account表里数据如下：

![img](https://github.com/hepengjun2022/doc-java/blob/master/pic/Mysql-%E9%97%B4%E9%9A%99%E9%94%81%E4%BE%8B%E5%AD%90.png?raw=true)

那么间隙就有 id 为 (3,10)，(10,20)，(20,正无穷) 这三个区间，在Session_1下面执行 update account set name = 'zhuge' where id > 8 and id <18;，则其他Session没法在这个**范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙**里插入或修改任何数据，即id在 (3,20]区间都无法修改数据，注意最后那个20也是包含在内的。 

**注意：间隙锁是在可重复读隔离级别下才会生效。** 

## 4.6、临键锁

Next-key Locks

### 1.介绍

<font color='red'>Next-Key Locks是行锁与间隙锁的组合。</font>像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。 

**无索引行锁会升级为表锁**

锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁：

1. session1 执行：update account set balance = 800 where name = 'lilei'; 

2. session2 对该表任一行操作都会阻塞住。

 **注意：InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。**

<font color='red'>锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)。</font>

例如：

```mysql
select  *  from test_innodb_lock where a = 2 for update
```

这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交 。

### 2.总结

1. Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。

2. 当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。 

3. 但是Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。

## 4.7、死锁

**set tx_isolation='repeatable-read';** 

Session_1执行：

```mysql
select * from account where id=1 for update; 
```

Session_2执行：

```mysql
select * from account where id=2 for update; 
```

Session_1执行：

```mysql
select * from account where id=2 for update; 
```

Session_2执行：

```mysql
select * from account where id=1 for update; 
```

查看近期死锁日志信息：

```mysql
show engine innodb status\G; 
```

大多数情况mysql可以自动检测死锁并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁。

**锁优化建议：**

+ 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 

+ 合理设计索引，尽量缩小锁的范围。

+ 尽可能减少检索条件范围，避免间隙锁。

+ 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行。

+ 尽可能低级别事务隔离。

# 十、面试题

**1.为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？**

**必须建主键**：在 mysql 的数据存储中 idb 文件中，要使用一颗聚簇索引来维护一个 b+ 树保存数据。

 mysql 在组织索引的时候，会依赖唯一id，有下列几种情况：

1. 如果有一个主键，可以直接使用主键建索引
2. 如果没有主键，会从第一列开始选择一列所有值都不相同的，作为索引列
3. 如果没有选到唯一值的索引列，mysql 会帮忙建立一个隐藏列（内置6字节长的ROWID作为隐含的聚集索引），维护一个唯一id，以此来组织索引那么为了避免 mysql 选择索引列和建立隐藏列的性能损耗，建议手动建立一个主键。

**推荐使用整型**：使用整形作为主键相比字符型可以节省数据页的空间。

**自增主键**：因为索引结构 b+ 树，具有有序的特性，如果主键不是自增的，在进行增删数据的时候，会判断数据应该存放的位置，进行插入和删除，为了保持平衡，会对数据页进行分裂等操作移动数据，严重影响性能，所以主键需要是自增的，插入时，插入在索引数据页最后。

**2.为什么非主键索引结构叶子结点存储的是主键值？**

**1. 保持一致性：**当数据库表进行DML操作时，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需进行更改。

**2. 节省存储空间：**Innodb数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据。

另外：

- 数据冗余。虽然提升了查询性能，但是需要更多的空间来存储冗余的数据。
- 维护麻烦。一个地方修改数据，需要在多棵索引树上修改。